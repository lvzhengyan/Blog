# CSS选择器

严格来说，选择器的种类可以分成三种
* 标签选择器
* 类选择器
* ID选择器

而在标签内写入 `style=""` 的方式，应该是 CSS 的一种引入方式，叫内联样式，而不是选择器。

然后将以上几种基本选择器组合在一起，就有多种复合的选择器了。

下图便是一些常见的 CSS 选择器组合，其中按照 CSS 选择器的效率从高到低排序

| 选择器       | 用法                     | 特殊说明                                                                                                             |
| ------------ | ------------------------ | -------------------------------------------------------------------------------------------------------------------- |
| ID选择器     | #selector                |                                                                                                                      |
| 类选择器     | .selector                |                                                                                                                      |
| 标签选择器   | div,h1,p                 |                                                                                                                      |
| 相邻选择器   | h1+p                     | 介于两个选择器之间，当第二个元素紧跟在第一个元素之后，并且两个元素都是属于同一个父元素的子元素，则第二个元素将被选中 |
| 子选择器     | ul > li                  | 只会匹配那些作为第一个元素的直接后代(子元素)的第二元素                                                               |
| 类选择器     | .selector                | 表示匹配存在的所有由第一个元素作为祖先元素(但不一定是父元素)的第二个元素, 无论它在 DOM 中"跳跃" 多少次               |
| 通配符选择器 | *                        |                                                                                                                      |
| 属性选择器   | a[rel="external"]        |                                                                                                                      |
| 伪类选择器   | a:hover, li:nth-child(n) |                                                                                                                      |

## CSS 选择器匹配规则

从下面这个例子来看一下 CSS 选择器是如何工作的：
```
.mod-nav h3 span {font-size: 16px;}
```
如果不知道匹配规则，可能的理解是从左向右匹配:先找到.mod-nav，然后逐级匹配h3、span，在这个过程中如果遍历到叶子节点都没有匹配就需要回溯，继续寻找下一个分支。

但实际上，CSS 选择器读取顺序是**从右往左**

还是上面的例子，它的读取顺序变成：先找到所有的span，沿着span的父元素查找h3，中途找到了符合匹配规则的节点就加入结果集；如果直到根元素html都没有匹配，则不再遍历这条路径，从下一个span开始重复这个过程（如果有多个最右节点为span的话）。

在某条CSS规则下（比如.mod-nav h3 span），会形成一条符合规则的索引树，树由上至下的节点是规则中从右向左的一个个选择符匹配的节点。

那为什么要这样设置 CSS 选择器的匹配规则呢，总不会无缘无故用不符合常理的方式来进行 CSS 的匹配吧

其实最为重要的原因就是：**从右向左的规则更加高效**

若从左向右的匹配，过程是：从.mod-nav开始，遍历子节点 h3，然后在所有的 h3 中去寻找 span。如果发现 span 不符合规则，就需要回溯到 h3 节点，遍历下一个 h3 节点。这样回溯会损失很多性能。

再看看从右至左的匹配：先找到所有的最右节点span，对于每一个span，向上寻找节点h3，由h3再向上寻找class=mod-nav的节点，最后找到根元素html则结束这个分支的遍历。

很明显，两种匹配规则的性能差别很大。之所以会差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点）；而从左向右的匹配规则的性能都浪费在了失败的查找上面。

当然这是比较明显情况，如果在叶子上存在多个不符合条件的span，从右向左的规则也会走一些弯路（这时就需要优化CSS选择器了）。但平均来说它还是更高效，因为大多时候，一个DOM树中，符合匹配条件的节点（如.mod-nav h3 span）远远远远少于不符合条件的节点。

## 提升 CSS 选择器的性能

CSS 性能优化的地方很多，比如：
* 慎重使用高性能属性：浮动、定位
* 尽量减少页面重排、重绘
  * 重排
    * 位置：position、top、left、z-index、float、display
    * 大小：width、height、margin、padding
    * 文字：font、line-height、color、letter-spacing
    * 背景边框：background、border
    * 动画：animation、transition
  * 重绘
    * border、outline、background、box-shadow
* 去除空规则： {}
* 尽量少使用 @import 前缀，它会影响 CSS 的加载速度
* CSS 雪碧图

以上提到的都是 CSS 性能优化，对于 CSS 选择器相关的性能优化有以下内容

1. 避免使用通用选择器
    ```
    .content {color: red;}
    ```
    浏览器匹配文档中所有的元素后分别向上逐级匹配 class 为 content 的元素，直到文档的根节点。因此其匹配开销是非常大的，所以应避免使用关键选择器是通配选择器的情况。

2. 避免使用标签或 class 选择器限制 ID 和 class 选择器
    ```
    /* 避免使用 */
    button#backButton{...}
    button.backButton{...}
    /* 推荐使用 */
    #backButton{...}
    .backButton{...}
    ```

3. 选择器优化嵌套，尽量避免层级过深

4. 减少后代选择器的使用
    ```
    div p {
        color: red;
        font-size: 14px;
    }
    ```
    这里浏览器首先会找到所有 p 标签，然后再向上查找包含 class 为 div 的标签。这样依赖如果代码中有很多 p 标签，无疑是会做很多重复工作的。

5. 使用继承
    ```
    /* 避免使用 */
    #bookmarkMenuItem > .menu-left { list-style-image: url(blah) }

    /* 推荐使用 */
    #bookmarkMenuItem { list-style-image: url(blah) }
    ```

## CSS 样式的优先级
CSS 样式生效也会有优先级，判断优先级主要有以下三种方式：

1. 是否直接选中
直接选中指的是直接选中要设置css样式的标签，和标签的id或者class类名。（间接选中就是指的是继承性，比如选择<ul>那里面的li继承ul的属性，就称为继承属性）
如果是间接选中，谁离目标标签比较近就听谁的。
如果选择器里有直接选中和间接选中。哪怕是间接的选择器为id选择器，也会优先实行直接选中的效果


2. 是否是相同的选择器
如果是相同选择器，那么就是谁写在后面就听谁的。


3. 不同的选择器
如果都是直接选中，并且不是相同类型的选择器，那么就会按照选择器的优先级来层叠（id>类>标签>通配符>继承>浏览器默认）