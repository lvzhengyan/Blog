# 正则表达式

## 是什么
在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。

## 元字符

| 代码 | 说明                         |
| ---- | ---------------------------- |
| .    | 匹配除换行符以外的任意字符   |
| \w   | 匹配字母或数字或下划线或汉字 |
| \s   | 匹配任意的空白符             |
| \d   | 匹配数字                     |
| \b   | 匹配单词的开始或结束         |
| ^    | 匹配字符串的开始             |
| $    | 匹配字符串的结束             |

我们来看一些例子:
* `\ba\w*\b` 匹配以字母 a 开头的单词
* `\bw{6}\b` 匹配刚好六个字符的单词
* `^\d{5,12}$` 匹配5到12位数字，常用于 QQ 号的验证



## 反义
有时候需要查找不属于某个能简单定义的字符类字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义:

| 代码 | 说明                                       |
| ---- | ------------------------------------------ |
| \W   | 匹配任意不是字母或数字或下划线或汉字的字符 |
| \S   | 匹配任意不是空白符的字符                   |
| \D   | 匹配任意非数字的字符                       |
| \B   | 匹配不是单词开头或结束的位置               |
| [^X] | 匹配除了X以外的任意字符                    |

从上边表格可以看出，部分反义的代码和元字符很像，就是字母大小写的区别，大写的字母就是反义，表示不是小写字母匹配的字符


我们来看一些例子:
* `[^aeiou]` 匹配除了 aeiou 这几个字母以外的任意字符
* `\S+` 匹配不包含空白符的字符串
* `<a[^>]+>` 匹配用尖括号括起来的以a开头的字符串



## 限定符（指定数量的代码）

| 代码  | 说明               |
| ----- | ------------------ |
| *     | 重复零次或者更多次 |
| +     | 重复一次或者更多次 |
| ?     | 重复零次或者一次   |
| {n}   | 重复n次            |
| {n,}  | 重复n次或者更多次  |
| {n,m} | 重复n到m次         |

我们来看一些例子:
* `Windows\d+` 匹配 Windows 后面跟一个或者多个数字
* `^\w+` 匹配一行的第一个单词（或整个字符串的第一个单词，具体匹配哪个意思得看选项设置）


## 字符类
上面我们提到了要想查找数字，字母或者空白是很简单的，但是想找一个范围内的字符（比如想找元音字母a,e,i,o,u）应该怎么找呢？

这里，正则的语法提供了一个 `[]`,用于指定一个字符范围，像 `[aeiou]` 就匹配任何一个英文元音字母，`[0-8]` 就匹配数字0-8中的一个。

因为指定一个范围，因此这个也可以表示上文中说到的元字符的，像`[0-9]`代表的含义与 `\d`是完全一样的

我们看一个比较复杂的表达式:
* `\(?0\d{2}[)-]?\d{8}` 这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符\(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\d{8})。

## 分支条件
有时候，我们要匹配的规则是几种规则中的一个，就是类似中文 "或者" 的形式，也就是正则表达式是中的分支条件。分支条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用 `|` 把不同的规则分隔开。

我们来看一些例子:
* `0\d{2}-\d{8}|0\d{3}-\d{7}` 这个表达式能匹配3位区号，本地号为8位的电话号码（023-12345678），同时也能匹配4位区号，本地号为7位的电话号码。

## 分组
上文中已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了），但是如果想要重复多个字符怎么办呢？

这里可以使用 `()` 来指定子表达式（分组），然后就可以指定这个子表达式的重复次数了

我们来看一些例子:
* `(\d{1,3}\.){3}\d{1,3}` 这个一个简单的 IP 地址匹配的表达式。但是并没有限定大小，因此是并不是最规范的写法。
* `((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)` 这是最规范的匹配 IP 地址的正则表达式


## 贪婪与懒惰匹配
### 贪婪
贪婪指的是一种规则，当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：`a.*b`，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。

### 懒惰
但是有时候我们需要的是匹配尽可能少的字符，这就是懒惰匹配。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号 ?。

| 代码   | 说明                              |
| ------ | --------------------------------- |
| *?     | 重复零次或者更多次,但尽可能少重复 |
| +?     | 重复一次或者更多次,但尽可能少重复 |
| ??     | 重复零次或者一次,但尽可能少重复   |
| {n,}?  | 重复n次或者更多次,但尽可能少重复  |
| {n,m}? | 重复n到m次,但尽可能少重复         |


## 其它语法
上面的介绍已经涵盖了大部分的正则表达式的使用，有一些并没有那么常用的可以在用到了再找资料看，比如后向引用、零宽断言、负向零宽断言、注释还有递归匹配。

其实正则表达式没有太多的诀窍，孰能生巧是对于正则使用最好的方法。